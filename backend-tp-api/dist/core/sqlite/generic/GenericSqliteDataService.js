"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericSqliteDataService = void 0;
const tslib_1 = require("tslib");
const IdHelper_1 = require("../../itf/generic/IdHelper");
const errorWithStatus_1 = require("../../../error/errorWithStatus");
const sqlite = tslib_1.__importStar(require("sqlite3"));
const sqlite3 = sqlite.verbose();
const db_connections_1 = require("../../db-connections");
class GenericSqliteDataService {
    // idHelper may be replaced/override in subclass:
    //by default id = alias for rowid (auto generated by sqlite)
    //may be overrided by static id (copy_or_renaming of .num or .code)
    constructor(connectionName, tableName, idHelper = new IdHelper_1.AutoIdHelper()) {
        this.connectionName = connectionName;
        this.tableName = tableName;
        this.idHelper = idHelper;
    }
    //dbB() = utility function for accessing sqlite connection initialized in myAppConnectionMap
    dB() {
        return new Promise((resolve, reject) => {
            let mySqliteConnection = db_connections_1.myAppConnectionMap.getConnection(this.connectionName);
            if (mySqliteConnection.isInitialized())
                resolve(mySqliteConnection.currentDb());
            else {
                mySqliteConnection.openConnection()
                    .then((msg) => { resolve(mySqliteConnection.currentDb()); })
                    .catch((err) => reject(err));
            }
        });
    }
    //NB: on doit pouvoir facilement basculer d'une base
    //sqlite avec souvent id ou _id ou rowid de type number
    //vers une base mongoDB avec souvent _id de type string
    //si model avec _id de type string , on ajutera une conversion en base:
    adjustEntitiesId(entities) {
        for (let e of entities) {
            this.adjustEntityId(e);
        }
        return entities;
    }
    adjustEntityId(e) {
        if (this.idHelper.isAuto() && typeof this.idHelper.getDefaultInitialValue() == "string") {
            let sId = this.idHelper.extractId(e);
            sId = sId.toString();
            this.idHelper.setId(e, sId);
        }
        return e;
    }
    findOne(query) {
        //NB: V1 (simple) query considérée comme clause vide ou "WHERE fielName=Value" sans "?"
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                let sql = "SELECT * FROM " + this.tableName + query;
                //console.log("sql="+sql);
                db.get(sql, [], (err, row) => {
                    if (err != null) {
                        console.log("findOne error = " + err + " with query=" + query);
                        reject(new errorWithStatus_1.ErrorWithStatus("findList exception / internal error"));
                    }
                    else {
                        if (row)
                            resolve(this.adjustEntityId(row));
                        else
                            reject(new errorWithStatus_1.NotFoundError("not found"));
                    }
                }); //end of db.all()
            }); //end of this.dB().then()
        }); //end of Promise
    }
    findById(id) {
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                let sql = "SELECT * FROM " + this.tableName + " WHERE " + this.idHelper.getIdPropName() + "=?";
                //console.log("sql="+sql);
                db.get(sql, id, (err, row) => {
                    if (err != null) {
                        console.log("findById error = " + err);
                        reject(new errorWithStatus_1.NotFoundError("not found "));
                    }
                    else { //NB: row may be null if not found
                        if (row)
                            resolve(this.adjustEntityId(row));
                        else
                            reject(new errorWithStatus_1.NotFoundError("not found"));
                    }
                }); //end of db.get()
            }); //end of this.dB().then()
        }); //end of Promise
    }
    findList(query) {
        //NB: V1 (simple) query considérée comme clause vide ou "WHERE fielName=Value" sans "?"
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                let sql = "SELECT * FROM " + this.tableName + query;
                //console.log("sql="+sql);
                db.all(sql, [], (err, rows) => {
                    if (err != null) {
                        console.log("findList error = " + err + " with query=" + query);
                        reject(new errorWithStatus_1.ErrorWithStatus("findList exception / internal error"));
                    }
                    else {
                        resolve(this.adjustEntitiesId(rows));
                    }
                }); //end of db.all()
            }); //end of this.dB().then()
        }); //end of Promise
    }
    findAll() {
        return this.findList("");
    }
    saveOrUpdate(dataObj) {
        //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
        let id = this.idHelper.extractId(dataObj);
        //console.log("in saveOrUpdate() , id="+id);
        if (this.idHelper.isAuto() && id == null) {
            return this.insert(dataObj);
        }
        else {
            return new Promise((resolve, reject) => {
                this.findById(id)
                    .then((existingEntityToUpdate) => {
                    //console.log("existing - need to be updated");
                    this.update(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                })
                    .catch((notFoundErr) => {
                    //console.log("non existing - need to be inserted");
                    this.insert(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                });
            });
        }
    }
    sqlInsertFromFieldList(e) {
        let arrayOfPropKeys = Reflect.ownKeys(e); //may ignoring inheritance in old version
        let fieldNameList = "(";
        let fieldParamList = "(";
        for (let propKey of arrayOfPropKeys) {
            let propName = propKey;
            fieldNameList += (propName + ",");
            fieldParamList += "?,";
        }
        fieldNameList = fieldNameList.replace(/.$/, ")");
        fieldParamList = fieldParamList.replace(/.$/, ")");
        let sql = "INSERT INTO " + this.tableName + fieldNameList + " VALUES" + fieldParamList;
        //console.log("sql=" + sql);
        return sql;
    }
    sqlUpdateFromFieldList(e) {
        let idPropName = this.idHelper.getIdPropName();
        let arrayOfPropKeys = Reflect.ownKeys(e); //may ignoring inheritance in old version
        let fieldSetList = "";
        for (let propKey of arrayOfPropKeys) {
            let propName = propKey;
            if (propName != idPropName)
                fieldSetList += (propName + "=? ,");
        }
        fieldSetList = fieldSetList.replace(/.$/, " ");
        let sql = "UPDATE " + this.tableName + " SET " + fieldSetList + " WHERE " + idPropName + "=?";
        //console.log("sql=" + sql);
        return sql;
    }
    sqlInsertFieldValues(e) {
        let fieldVals = [];
        let arrayOfPropKeys = Reflect.ownKeys(e);
        for (let propKey of arrayOfPropKeys) {
            let propName = propKey;
            let fieldValue = Reflect.get(e, propName);
            fieldVals.push(fieldValue);
        }
        return fieldVals;
    }
    sqlUpdateFieldValues(e) {
        let idPropName = this.idHelper.getIdPropName();
        let fieldVals = [];
        let arrayOfPropKeys = Reflect.ownKeys(e);
        for (let propKey of arrayOfPropKeys) {
            let propName = propKey;
            if (propName != idPropName) {
                let fieldValue = Reflect.get(e, propName);
                fieldVals.push(fieldValue);
            }
        }
        let idFieldValue = Reflect.get(e, idPropName);
        fieldVals.push(idFieldValue); //en remplacement du dernier ?
        return fieldVals;
    }
    insert(e) {
        return new Promise((resolve, reject) => {
            let idHelper = this.idHelper;
            let idPropName = this.idHelper.getIdPropName();
            this.dB().then((db) => {
                var pst = db.prepare(this.sqlInsertFromFieldList(e));
                pst.run(this.sqlInsertFieldValues(e), function (err) {
                    //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                    if (err != null) {
                        console.log("generic insert error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("sql insert exception / internal error"));
                    }
                    else {
                        if (this.changes == 0)
                            reject(new errorWithStatus_1.NotFoundError("not inserted "));
                        else {
                            if (idHelper.isAuto) {
                                let lastID = this.lastID; //as number
                                if (typeof idHelper.getDefaultInitialValue() == "string") {
                                    lastID = lastID.toString();
                                }
                                Reflect.set(e, idPropName, lastID);
                            }
                            resolve(e);
                        }
                    }
                }); //end of db.run()
                pst.finalize();
            }); //end of this.dB().then()
        }); //end of Promise
    }
    update(e) {
        return new Promise((resolve, reject) => {
            let idPropName = this.idHelper.getIdPropName();
            this.dB().then((db) => {
                var pst = db.prepare(this.sqlUpdateFromFieldList(e));
                pst.run(this.sqlUpdateFieldValues(e), function (err) {
                    //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                    if (err != null) {
                        console.log("generic update error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("sql update exception / internal error"));
                    }
                    else {
                        if (this.changes == 0)
                            reject(new errorWithStatus_1.NotFoundError("not updated "));
                        else {
                            resolve(e);
                        }
                    }
                }); //end of db.run()
                pst.finalize();
            }); //end of this.dB().then()
        }); //end of Promise
    }
    remove(query) {
        //NB: V1 (simple) query considérée comme clause vide ou "WHERE fielName=Value" sans "?"
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                let sql = "DELETE FROM " + this.tableName + query;
                //console.log("sql="+sql);
                db.run(sql, [], function (err) {
                    //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                    if (err != null) {
                        console.log("generic remove error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("sql delete exception / internal error"));
                    }
                    else {
                        if (this.changes == 0)
                            reject(new errorWithStatus_1.NotFoundError("not found "));
                        else
                            resolve();
                    }
                }); //end of db.run()
            }); //end of this.dB().then()
        }); //end of Promise
    }
    deleteById(id) {
        return new Promise((resolve, reject) => {
            this.dB().then((db) => {
                let sql = "DELETE FROM " + this.tableName + " WHERE " + this.idHelper.getIdPropName() + "=?";
                //console.log("sql="+sql);
                db.run(sql, id, function (err) {
                    //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                    if (err != null) {
                        console.log("genericDeleteById error = " + err);
                        reject(new errorWithStatus_1.ErrorWithStatus("sql delete exception / internal error"));
                    }
                    else {
                        if (this.changes == 0)
                            reject(new errorWithStatus_1.NotFoundError("not found "));
                        else
                            resolve();
                    }
                }); //end of db.run()
            }); //end of this.dB().then()
        }); //end of Promise
    }
}
exports.GenericSqliteDataService = GenericSqliteDataService;
